# -*- coding: utf-8 -*-
"""Q14.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ITNgj1W-vKVVwm2J2RNivYy6-4dZV-51

# Question 14

**Part-A**

In this case, we have for the voltages $V_1$ and $V_{N-1}$ , which are connected to 3 wires.

$$\frac{V_1-V_+}{R}+\frac{V_1 -V_2}{R} +\frac{V_1- V_3}{R}=0$$
$$\frac{V_N}{R}+\frac{V_N -V_{N-1}}{R} +\frac{V_N- V_{N-2}}{R}=0$$

which translates into:
$$3V_1 - V_2 -V_3 -V_+=0$$
$$-V_{N-2} -V_{N-1} +3V_N=0$$

If we treat $V_+=V_0$ and $V_{N+1}=0$, then for all $2 \leq i \leq V_{N-1}$, we must have:

$$\frac{V_i-V_{i-2}}{R}+\frac{V_i -V_{i-1}}{R} +\frac{V_i- V_{i+1}}{R}+\frac{V_i-V_{i+2}}{R}=0\\ \implies -V_{i-2} -V_{i-1} +4V_i -V_{i+1} - V_{i+2}=0$$

which generates all the equations we need.

**Part-B**

This case the equations are represented by the matrix:

$$\begin{pmatrix}
3 & -1 & -1 & 0 & 0 & 0\\
-1 & 4 & -1 & -1 & 0 & 0\\
-1 & -1 & 4 & -1 & -1 & 0\\
0 & -1 & -1 & 4 & -1 & -1\\
0 & 0 & -1 & -1 & 4 & -1\\
0 & 0 & 0 & -1 & -1 & 3\\
\end{pmatrix}\begin{pmatrix}V_1\\ V_2\\ V_3\\ V_4\\ V_5\\ V_6 \end{pmatrix}= \begin{pmatrix} 5 \\\ 5 \\ 0 \\ 0 \\ 0 \\ 0 \end{pmatrix}$$
"""

import numpy as np
import math

N=6
Vp=5

def create_mat(N):
  A=np.zeros([N,N])
  A[0][0]=A[N-1][N-1]=3
  A[0][:3]=[3, -1, -1]
  A[N-1][N-3:N]=[-1, -1, 3]
  A[1][:4]=[-1, 4, -1, -1]
  A[N-2][N-4:N]=[-1, -1, 4, -1]
  for i in range(2,N-2):
    A[i, max(0, i-2):min(N, i+3)]=[-1, -1, 4, -1, -1]
  return np.matrix(A)

sol=np.zeros(N)
sol[1]=Vp
sol[0]=Vp

#gaussian is used in linalg. solve
V=np.linalg.solve(create_mat(N),sol)
print('the voltages are:', V)

#part b
# In these case we modify the algorithm according to the banded Gaussian approach. We modify the previous program.



from numpy import copy

def banded(Aa,va,up,down):

    # Copy the inputs and determine the size of the system
    A = copy(Aa)
    v = copy(va)
    N = len(v)

    # Gaussian elimination
    for m in range(N):

        # Normalization factor
        div = A[up,m]

        # Update the vector first
        v[m] /= div
        for k in range(1,down+1):
            if m+k<N:
                v[m+k] -= A[up+k,m]*v[m]

        # Now normalize the pivot row of A and subtract from lower ones
        for i in range(up):
            j = m + up - i
            if j<N:
                A[i,j] /= div
                for k in range(1,down+1):
                    A[i+k,j] -= A[up+k,m]*A[i,j]

    # Backsubstitution
    for m in range(N-2,-1,-1):
        for i in range(up):
            j = m + up - i
            if j<N:
                v[m] -= A[i,j]*v[j]

    return v


N=10000
v=np.zeros(N)
v[0]=Vp
v[1]=Vp

m=create_mat(10000)
print(m)

from numpy import empty

v=np.zeros(N)
v[0]=Vp
v[1]=Vp
V=banded(m,v, 2, 2)

print(V)



